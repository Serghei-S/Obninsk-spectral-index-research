import React, { useState, useEffect, useRef } from 'react'
import api from '../utils/api'
import { Line } from 'react-chartjs-2'
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
} from 'chart.js'
import SaveFieldButton from './SaveFieldButton'
import AddToDashboardButton from './AddToDashboardButton'
import './TimeSeriesModal.css'

// Register Chart.js components
ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
)

const VEGETATION_INDICES_OPTIONS = [
  { value: 'NDVI', label: 'NDVI - –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –≤–µ–≥–µ—Ç–∞—Ü–∏–æ–Ω–Ω—ã–π –∏–Ω–¥–µ–∫—Å', color: '#22c55e', bgColor: 'rgba(34, 197, 94, 0.1)' },
  { value: 'EVI', label: 'EVI - –£–ª—É—á—à–µ–Ω–Ω—ã–π –≤–µ–≥–µ—Ç–∞—Ü–∏–æ–Ω–Ω—ã–π –∏–Ω–¥–µ–∫—Å', color: '#3b82f6', bgColor: 'rgba(59, 130, 246, 0.1)' },
  { value: 'PSRI', label: 'PSRI - –ò–Ω–¥–µ–∫—Å —Å—Ç–∞—Ä–µ–Ω–∏—è —Ä–∞—Å—Ç–µ–Ω–∏–π', color: '#f59e0b', bgColor: 'rgba(245, 158, 11, 0.1)' },
  { value: 'NBR', label: 'NBR - –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –∏–Ω–¥–µ–∫—Å –≥–∞—Ä–∏', color: '#ef4444', bgColor: 'rgba(239, 68, 68, 0.1)' },
  { value: 'NDSI', label: 'NDSI - –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π —Å–Ω–µ–∂–Ω—ã–π –∏–Ω–¥–µ–∫—Å', color: '#06b6d4', bgColor: 'rgba(6, 182, 212, 0.1)' },
]

function TimeSeriesModal({ selectedGeometry, onClose }) {
  const chartRef = useRef(null)
  const [startDate, setStartDate] = useState('')
  const [endDate, setEndDate] = useState('')
  const [selectedIndices, setSelectedIndices] = useState(['NDVI']) // Multiple indices support
  const [chartData, setChartData] = useState(null)
  const [rawData, setRawData] = useState(null) // Store raw data for CSV export
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState(null)

  useEffect(() => {
    // Set default dates to last 3 months
    const today = new Date()
    const threeMonthsAgo = new Date(today)
    threeMonthsAgo.setMonth(today.getMonth() - 3)

    setStartDate(threeMonthsAgo.toISOString().split('T')[0])
    setEndDate(today.toISOString().split('T')[0])
  }, [])

  const handleAnalyzeDynamics = async () => {
    if (!selectedGeometry) {
      setError('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –æ–±–ª–∞—Å—Ç—å –Ω–∞ –∫–∞—Ä—Ç–µ.')
      return
    }

    if (!startDate || !endDate) {
      setError('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –¥–∏–∞–ø–∞–∑–æ–Ω –¥–∞—Ç.')
      return
    }

    if (selectedIndices.length === 0) {
      setError('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –∏–Ω–¥–µ–∫—Å.')
      return
    }

    // Validate Sentinel-2 availability (launched June 23, 2015)
    const sentinel2Start = new Date('2015-06-23')
    const selectedStart = new Date(startDate)
    
    if (selectedStart < sentinel2Start) {
      setError('–î–∞–Ω–Ω—ã–µ Sentinel-2 –¥–æ—Å—Ç—É–ø–Ω—ã —Ç–æ–ª—å–∫–æ —Å 23 –∏—é–Ω—è 2015 –≥–æ–¥–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –±–æ–ª–µ–µ –ø–æ–∑–¥–Ω—é—é –¥–∞—Ç—É –Ω–∞—á–∞–ª–∞.')
      return
    }

    // Warn if range is too large
    const daysDiff = Math.floor((new Date(endDate) - new Date(startDate)) / (1000 * 60 * 60 * 24))
    if (daysDiff > 365) {
      if (!window.confirm('–í—ã–±—Ä–∞–Ω –±–æ–ª—å—à–æ–π –¥–∏–∞–ø–∞–∑–æ–Ω –¥–∞—Ç (>1 –≥–æ–¥–∞). –ê–Ω–∞–ª–∏–∑ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–∏–Ω—É—Ç. –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å?')) {
        return
      }
    }

    setError(null)
    setIsLoading(true)

    try {
      // Fetch data for all selected indices in parallel
      const requests = selectedIndices.map(indexType => 
        api.post('/api/v1/analyze/timeseries', {
          geometry: selectedGeometry,
          start_date: startDate,
          end_date: endDate,
          index_type: indexType,
        })
      )

      const responses = await Promise.all(requests)
      const allData = responses.map(response => response.data)

      // Check if we have any data
      if (allData.length === 0 || allData[0].dates.length === 0) {
        setError('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –∑–∞ –≤—ã–±—Ä–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥.')
        setIsLoading(false)
        return
      }

      // Store raw data for CSV export (all indices)
      setRawData(allData)

      // Create datasets for each index with unique colors
      const datasets = allData.map((data, index) => {
        const indexConfig = VEGETATION_INDICES_OPTIONS.find(opt => opt.value === selectedIndices[index])
        return {
          label: indexConfig.label.split(' - ')[0], // Short name
          data: data.values,
          fill: true,
          backgroundColor: indexConfig.bgColor,
          borderColor: indexConfig.color,
          tension: 0.4, // Smoother curves
          pointRadius: 3,
          pointHoverRadius: 6,
          pointBackgroundColor: indexConfig.color,
          pointBorderColor: '#fff',
          pointBorderWidth: 2,
          borderWidth: 3,
        }
      })

      setChartData({
        labels: allData[0].dates, // All should have same dates
        datasets: datasets,
      })
    } catch (err) {
      console.error('Error fetching time series data:', err)
      setError(err.response?.data?.detail || '–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ —Ä—è–¥–∞. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ credentials Sentinel Hub –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã –ø—Ä–∞–≤–∏–ª—å–Ω–æ.')
    } finally {
      setIsLoading(false)
    }
  }

  const options = {
    responsive: true,
    maintainAspectRatio: false,
    interaction: {
      mode: 'index',
      intersect: false,
    },
    plugins: {
      legend: {
        position: 'top',
        labels: {
          color: 'var(--text-color-primary)',
          font: {
            family: 'Inter, sans-serif',
            size: 14,
            weight: '500',
          },
          padding: 15,
          usePointStyle: true,
          pointStyle: 'circle',
        },
      },
      title: {
        display: true,
        text: `üõ∞Ô∏è –î–∏–Ω–∞–º–∏–∫–∞ –≤–µ–≥–µ—Ç–∞—Ü–∏–æ–Ω–Ω—ã—Ö –∏–Ω–¥–µ–∫—Å–æ–≤ (Sentinel-2)`,
        color: 'var(--text-color-primary)',
        font: {
          family: 'Inter, sans-serif',
          size: 20,
          weight: '700',
        },
        padding: {
          top: 15,
          bottom: 25
        }
      },
      tooltip: {
        backgroundColor: 'rgba(0, 0, 0, 0.8)',
        titleColor: '#fff',
        bodyColor: '#fff',
        borderColor: 'var(--border-color)',
        borderWidth: 1,
        padding: 12,
        displayColors: true,
        callbacks: {
          label: function(context) {
            let label = context.dataset.label || '';
            if (label) {
              label += ': ';
            }
            if (context.parsed.y !== null) {
              label += context.parsed.y.toFixed(4);
            }
            return label;
          }
        }
      }
    },
    scales: {
      x: {
        title: {
          display: true,
          text: 'üìÖ –î–∞—Ç–∞',
          color: 'var(--text-color-primary)',
          font: {
            family: 'Inter, sans-serif',
            size: 14,
            weight: '600',
          },
        },
        ticks: {
          color: 'var(--text-color-secondary)',
          maxRotation: 45,
          minRotation: 0,
          font: {
            size: 11,
          },
        },
        grid: {
          color: 'var(--border-color-light)',
          drawBorder: false,
        },
      },
      y: {
        title: {
          display: true,
          text: 'üìä –ó–Ω–∞—á–µ–Ω–∏–µ –∏–Ω–¥–µ–∫—Å–∞',
          color: 'var(--text-color-primary)',
          font: {
            family: 'Inter, sans-serif',
            size: 14,
            weight: '600',
          },
        },
        min: -1,
        max: 1,
        ticks: {
          color: 'var(--text-color-secondary)',
          font: {
            size: 11,
          },
        },
        grid: {
          color: 'var(--border-color-light)',
          drawBorder: false,
        },
      },
    },
  }

  // Export chart as PNG
  const exportChartAsPNG = () => {
    if (chartRef.current) {
      const url = chartRef.current.toBase64Image('image/png', 1.0)
      const link = document.createElement('a')
      const indicesStr = selectedIndices.join('_')
      link.download = `timeseries_${indicesStr}_${startDate}_${endDate}.png`
      link.href = url
      link.click()
    }
  }

  // Export data as CSV
  const exportDataAsCSV = () => {
    if (!rawData || rawData.length === 0) {
      alert('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞')
      return
    }

    // Create CSV header with all indices
    let csvContent = 'Date,' + selectedIndices.join(',') + '\n'
    
    // Add data rows
    const numRows = rawData[0].dates.length
    for (let i = 0; i < numRows; i++) {
      const row = [rawData[0].dates[i]]
      // Add values for each index
      rawData.forEach(data => {
        row.push(data.values[i])
      })
      csvContent += row.join(',') + '\n'
    }

    // Create blob and download
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' })
    const url = URL.createObjectURL(blob)
    const link = document.createElement('a')
    const indicesStr = selectedIndices.join('_')
    link.download = `timeseries_${indicesStr}_${startDate}_${endDate}.csv`
    link.href = url
    link.click()
    URL.revokeObjectURL(url)
  }

  // Toggle index selection
  const toggleIndex = (indexValue) => {
    setSelectedIndices(prev => {
      if (prev.includes(indexValue)) {
        // Don't allow removing if it's the last one
        if (prev.length === 1) return prev
        return prev.filter(i => i !== indexValue)
      } else {
        return [...prev, indexValue]
      }
    })
  }

  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal-content" onClick={(e) => e.stopPropagation()}>
        <div className="modal-header">
          <h2>üìà –ê–Ω–∞–ª–∏–∑ –¥–∏–Ω–∞–º–∏–∫–∏ –≤–µ–≥–µ—Ç–∞—Ü–∏–æ–Ω–Ω—ã—Ö –∏–Ω–¥–µ–∫—Å–æ–≤</h2>
          <button className="modal-close" onClick={onClose}>&times;</button>
        </div>

        <div className="modal-body">
          <div className="ts-controls">
            <div className="ts-control-row">
              <div className="ts-control-group">
                <label>–ù–∞—á–∞–ª—å–Ω–∞—è –¥–∞—Ç–∞ <span className="hint">(—Å 23.06.2015)</span></label>
                <input
                  type="date"
                  value={startDate}
                  onChange={(e) => setStartDate(e.target.value)}
                  min="2015-06-23"
                  max={endDate || undefined}
                  className="ts-input"
                />
              </div>

              <div className="ts-control-group">
                <label>–ö–æ–Ω–µ—á–Ω–∞—è –¥–∞—Ç–∞</label>
                <input
                  type="date"
                  value={endDate}
                  onChange={(e) => setEndDate(e.target.value)}
                  min={startDate || "2015-06-23"}
                  max={new Date().toISOString().split('T')[0]}
                  className="ts-input"
                />
              </div>

              <div className="ts-control-group ts-indices-group">
                <label>–ò–Ω–¥–µ–∫—Å—ã –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞</label>
                <div className="ts-indices-checkboxes">
                  {VEGETATION_INDICES_OPTIONS.map((option) => (
                    <label key={option.value} className="ts-checkbox-label">
                      <input
                        type="checkbox"
                        checked={selectedIndices.includes(option.value)}
                        onChange={() => toggleIndex(option.value)}
                        className="ts-checkbox"
                      />
                      <span className="ts-checkbox-custom" style={{ borderColor: option.color }}>
                        {selectedIndices.includes(option.value) && <span style={{ backgroundColor: option.color }}>‚úì</span>}
                      </span>
                      <span className="ts-checkbox-text">
                        <span className="ts-index-dot" style={{ backgroundColor: option.color }}></span>
                        {option.label.split(' - ')[0]}
                      </span>
                    </label>
                  ))}
                </div>
              </div>
            </div>

            <button
              onClick={handleAnalyzeDynamics}
              className="btn btn-primary ts-analyze-btn"
              disabled={isLoading || !selectedGeometry}
            >
              {isLoading ? (
                <>
                  <span className="spinner-small"></span>
                  –ó–∞–≥—Ä—É–∑–∫–∞...
                </>
              ) : (
                '–ê–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –¥–∏–Ω–∞–º–∏–∫—É'
              )}
            </button>
          </div>

          {error && <div className="error-message">{error}</div>}

          {!selectedGeometry && !error && (
            <div className="info-message">
              ‚ÑπÔ∏è –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –æ–±–ª–∞—Å—Ç—å –Ω–∞ –∫–∞—Ä—Ç–µ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –¥–∏–Ω–∞–º–∏–∫–∏
            </div>
          )}

          {chartData && (
            <>
              <div className="ts-export-buttons">
                <button 
                  className="btn btn-export" 
                  onClick={exportChartAsPNG}
                  title="–°–∫–∞—á–∞—Ç—å –≥—Ä–∞—Ñ–∏–∫ –∫–∞–∫ PNG"
                >
                  üì• –°–∫–∞—á–∞—Ç—å –≥—Ä–∞—Ñ–∏–∫ (PNG)
                </button>
                <button 
                  className="btn btn-export" 
                  onClick={exportDataAsCSV}
                  title="–°–∫–∞—á–∞—Ç—å –¥–∞–Ω–Ω—ã–µ –∫–∞–∫ CSV"
                >
                  üìÑ –°–∫–∞—á–∞—Ç—å –¥–∞–Ω–Ω—ã–µ (CSV)
                </button>
              </div>
              <div className="ts-chart-container">
                <Line ref={chartRef} data={chartData} options={options} />
              </div>
              <div className="ts-save-buttons">
                <SaveFieldButton 
                  geometry={selectedGeometry}
                  onFieldSaved={(field) => {
                    console.log('Field saved from time series:', field)
                  }}
                />
                <AddToDashboardButton 
                  geometry={selectedGeometry}
                  analysisParams={{
                    startDate: startDate,
                    endDate: endDate,
                    indexType: selectedIndices[0] // Use first selected index for dashboard
                  }}
                  itemType="time_series_chart"
                  onAdded={(item) => {
                    console.log('Added to dashboard from time series:', item)
                  }}
                />
              </div>
            </>
          )}

          {isLoading && (
            <div className="ts-loading">
              <div className="spinner"></div>
              <p>–ê–Ω–∞–ª–∏–∑ –¥–∞–Ω–Ω—ã—Ö –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ —Ä—è–¥–∞...</p>
            </div>
          )}
        </div>
      </div>
    </div>
  )
}

export default TimeSeriesModal

